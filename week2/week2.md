# week2
## homework1
ほぼ O(1) で動くハッシュテーブルを自分で実装してみよう

- ヒント 1🤗
    - delete(key) を実装してください
    - functional_test() が通れば合格です

- ヒント 2🤗
    - 再ハッシュを実装してデータを追加してもほぼ O(1) で動くようにしよう
    - 作り方の例：
        - 要素数がテーブルサイズの 70% を上回ったら、テーブルサイズを 2 倍に拡張
        - 要素数がテーブルサイズの 30% を下回ったら、テーブルサイズを半分に縮小
        - テーブルサイズは奇数（できれば素数）になるよう調整するとハッシュの衝突が減ります

- ヒント 3🤗
    - ハッシュ関数を見直そう
    - サンプルコードのハッシュ関数はあまり望ましいとは言えません
        - "alice" と "elica" が同じハッシュ値になって衝突
    - ハッシュの衝突を減らすにはハッシュ関数をどう工夫すればいいでしょう？

## homework2
木構造を使えば O(log N)、ハッシュテーブルを使えばほぼ O(1) で検索・追加・削除を実現することができて、これだけ見ればハッシュテーブルのほうが優れているように見える。ところが現実の大規模なデータベースでは、ハッシュテーブルではなく木構造が使われることが多い。その理由を考えよ。

## extra1
つねに O(1) で検索・追加・削除できるデータ構造はあるか？🤔
hash mapで常にkeyが必ず重複しないデータを作れればできる、気がする。
と思ったけどhashが検索できるのはsizeが有限だから？

## homework3
次の操作をほぼ O(1) で実現するデータ構造を考える
- 与えられた <URL, Web ページ> があるかないかを検索
- もしない場合、キャッシュ内で一番古い <URL, Web ページ> を捨てて、代わりに与えられた <URL, Web ページ> を追加する

- ヒント：
    - ハッシュテーブルだけだと順序を管理できないので、別のデータ構造を組み合わせて、X 個の <URL, Web ページ> をアクセスされた順に取り出せるようにする😀

単連結リストで順番を管理する。新しいのをheadにして、先頭から見ていって同じものがあれば削除する。無ければ最後の値を削除する

## homework4
- 宿題 3 のキャッシュを作ってみよう（余裕があれば）
