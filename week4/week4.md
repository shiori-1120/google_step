宿題１

find_shortest_path() 関数を書いて、あるページから別のページへの最短経路を出力してください😀
「渋谷」から「小野妹子」にどうたどり着く？
ヒント：
BFS に工夫を入れて最短経路を出せるようにする
collections.deque を使うとスタックやキューが作れます
30 行程度で書けます😀

宿題2

find_most_popular_pages() 関数を書いて、ページランクを計算して重要度の高いページトップ 10 を求めてください
このスライドで「言葉で説明したアルゴリズムを自分で具体化してコードに落とす」のが宿題の意図です
50 行程度で書けます 😀

ヒント
正しさの確認方法
ページランクの分配と更新を何回繰り返しても「全部のノードのページランクの合計値」が一定に保たれることを確認してください
一定にならない場合何かが間違ってます！

Large のデータセットで動かすためには O(N + E) のアルゴリズムが必要です
ページ数：N = 2215900
リンク数：E = 119006494

ページランクの更新が「完全に」収束するのは時間がかかりすぎるので、更新が十分少なくなったら止める

収束条件の作り方の例：
∑(new_pagerank[i] - old_pagerank[i])^2 < 0.01

宿題③

Wikipedia のグラフについて「渋谷」から「池袋」まで、同じページを重複して通らない、できるだけ長い経路を発見してください！！

「最長」経路を求めることは困難
最長経路問題は NP 困難と呼ばれる種類の問題で、多項式時間の計算量では解けないことが知られています（来週の授業で解説します）
なのでグラフ探索アルゴリズムを工夫して「できるだけ長い」経路を発見してください

ぼくが発見した長い経路
medium = 376138
large = 1130305

探索方法はいろいろ
高度なアルゴリズムを調べて使う必要はなく、今日の授業で解説した知識の範囲内で十分楽しめると思います
ぼくは BFS + DFS + ちょっとした工夫で探索しました！
70 行くらい

